package Graphs.Hard;

import java.util.Arrays;
import java.util.HashMap;
import java.util.PriorityQueue;

/**
 * Don't do this question its criteria for ordering initial nodes in not clear
 */
public class MinimizeMalwareSpread {
    int[] parent;
    int[] rank;
    HashMap<Integer, Integer> groupCount;
    int components;
    public boolean union(int a, int b){
        int parentA=getParent(a);
        int parentB=getParent(b);

        if(parentA==parentB)
            return false;

        if(rank[parentA]>rank[parentB]){
            groupCount.put(parentA, groupCount.get(parentB) + groupCount.get(parentA));
            groupCount.remove(parentB);
            parent[parentB]=parentA;
        }
        else if(rank[parentA]<rank[parentB]){
            groupCount.put(parentB, groupCount.get(parentB) + groupCount.get(parentA));
            groupCount.remove(parentA);
            parent[parentA]=parentB;
        }
        else {
            groupCount.put(parentA, groupCount.get(parentB) + groupCount.get(parentA));
            groupCount.remove(parentB);
            parent[parentB]=parentA;
            rank[parentA]++;
        }
        components--;
        return true;
    }

    public int getParent(int node){
        if(node==parent[node])
            return node;
        return parent[node]=getParent(parent[node]);
    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        parent=new int[graph.length];
        rank=new int[graph.length];
        groupCount = new HashMap<>();
        components=graph.length;

        for(int i=0;i< graph.length;i++){
            groupCount.put(i, 1);
            parent[i]=i;
        }

        for(int i=0;i<graph.length;i++){
            for (int j=i+1;j< graph.length;j++){
                if(graph[i][j]==1)
                    union(i,j);
            }
        }


        int[] counts=new int[graph.length];
        int[] correspondingNode = new int[graph.length];
        Arrays.fill(correspondingNode,Integer.MAX_VALUE);
        for (int i=0;i<initial.length;i++){
            getParent(initial[i]);
            counts[parent[initial[i]]]++;
            correspondingNode[parent[initial[i]]]=Math.min(correspondingNode[parent[initial[i]]],initial[i]);
        }
        PriorityQueue<Pair> queue=new PriorityQueue<>();
        for (int i=0;i<counts.length;i++)
            if(counts[i]!=0)
                queue.add(new Pair(i,counts[i],groupCount.get(i),correspondingNode[i]));
        return correspondingNode[queue.poll().parent];
    }

    static class Pair implements Comparable<Pair>{
        public int parent;
        int count;
        int groupCount;
        private int correspondingNode;

        public Pair(int parent, int count, int groupCount, int correspondingNode) {
            this.parent = parent;
            this.count = count;
            this.groupCount = groupCount;
            this.correspondingNode = correspondingNode;
        }

        @Override
        public int compareTo(Pair o) {
            /*if(count==o.count){
                if(o.groupCount==groupCount)
                    return correspondingNode-o.correspondingNode;
                return o.groupCount-groupCount;
            }*/
            if(count==1 && o.count==1){
                if(o.groupCount==groupCount)
                    return correspondingNode-o.correspondingNode;
                return o.groupCount-groupCount;
            }
            if(count==1 || o.count==1)
                return count-o.count;
            return correspondingNode-o.correspondingNode;
        }
    }

    public static void main(String[] args) {
        int[][] graph1={{1,1,0},{1,1,0},{0,0,1}};
        int[][] graph4={{1,0,0,0,1,0,0,0,0,0,1},{0,1,0,1,0,0,0,0,0,0,0},{0,0,1,0,0,0,0,1,0,0,0},{0,1,0,1,0,1,0,0,0,0,0},{1,0,0,0,1,0,0,0,0,0,0},{0,0,0,1,0,1,0,0,1,1,0},{0,0,0,0,0,0,1,1,0,0,0},{0,0,1,0,0,0,1,1,0,0,0},{0,0,0,0,0,1,0,0,1,0,0},{0,0,0,0,0,1,0,0,0,1,0},{1,0,0,0,0,0,0,0,0,0,1}};
        int[][] graph2={{1,0,0,0},{0,1,0,0},{0,0,1,1},{0,0,1,1}};
        int[][] graph3={{1,0,0,0,0,0,1},{0,1,0,1,0,0,0},{0,0,1,0,1,0,1},{0,1,0,1,0,1,0},{0,0,1,0,1,0,0},{0,0,0,1,0,1,0},{1,0,1,0,0,0,1}};
        //System.out.println(new MinimizeMalwareSpread().minMalwareSpread(graph1,new int[]{0,1}));
        //System.out.println(new MinimizeMalwareSpread().minMalwareSpread(graph2,new int[]{3,1}));
        System.out.println(new MinimizeMalwareSpread().minMalwareSpread(graph4,new int[]{7,8,6,2,3}));
    }
}
